% !TeX root = ./pf2022.tex

%\includeonlyframes{current}

\section{Data abstraction}

\begin{frame}{Data abstraction}
  \begin{itemize}[<+->]
  \item The \Cpp{} language has a strong focus on building lightweight data
    abstractions
    \begin{itemize}
    \item The source code can use terminology and notation close to the problem
      domain, making it more expressive
    \item There is little (if any) overhead in terms of space or time during
      execution
    \end{itemize}
  \item \code{class} and \code{struct} are the primary mechanism to define new
    compound types on top of fundamental types
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Data structure}

  \begin{itemize}
  \item Let's introduce a type to represent complex numbers
  \item<3-> We can pass/return \code{Complex} objects to/from
    functions\uncover<4->{, take pointers and references, \ldots}
  \end{itemize}

  \vskip -.5cm

  \begin{columns}[t]

    \begin{column}{.5\textwidth}

  \begin{codeblock}<2->{
struct Complex \{
  \alt<-5|trans:0>{\ddd
  }{double r; // data member
  double i;}
\};

\uncover<3->{double norm2(Complex c);
Complex sqrt(Complex c);

Complex c\{\alt<-5>{\ddd}{1., 2.}\};
double n\{ norm2(c) \};
Complex c2\{ sqrt(c) \};}

\uncover<4->{Complex& cr\{c\};  // reference}
\uncover<4->{Complex* cp\{&c\}; // pointer}}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<5->{
double norm2(Complex c) \{
  return \uncover<7->{c\alert<7>{.}r * c\alert<7>{.}r + c\alert<7>{.}i * c\alert<7>{.}i};
\}

\uncover<8->{double norm2(Complex\alert<8|trans:0>{ const\&} c) \{
  return \uncover<9->{c.r * c.r + c.i * c.i};
\}}}\end{codeblock}

      \begin{itemize}
      \item<6-> A \code{Complex} is composed of two \code{double}s
      \item<7-> The \code{.} (dot) operator allows to access a member of an
        object of \textit{class type} (such as a \code{struct})
      \end{itemize}
    \end{column}

  \end{columns}

  \vskip -1cm

  \begin{tikzpicture}[
      anchor=south west,
      node distance=0,
    ]
    
    \visible<3->{
      \node at (0,0) [memory] {};

      \node at (2.9,-0.1) [
        rectangle,
        "\code{c}" below,   
        fill=green!10!white,
        draw=black!40,
        minimum width=2.2cm,
        minimum height=0.7cm,
      ] {};
    }
    \visible<6->{
      \node (r) at (3,0) [word, "\code{r}" above] {\only<6->{1.}};
      \node (i) [word, right=of r, "\code{i}" above] {\only<6->{2.}};
    }
    
  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]{Operations}

  It's possible to define operations on user-defined types

  \begin{codeblock}
struct Complex \{
  double r;
  double i;
\};

\uncover<3->{bool \uncover<4->{\alert<4>{operator==}}(Complex const& a, Complex const& b) \{
  return a.r == b.r && a.i == b.i;
\}}

\uncover<5->{Complex \uncover<6->{\alert<6>{operator+}}(Complex const& a, Complex const& b) \{
  return Complex\{a.r + b.r, a.i + b.i\};
\}}

c2 \alert<2>{=} c1\uncover<2->{       // \alert<2>{generated by the compiler, if used}}
c1 \alert<3-4>{==} c2
c1 \alert<5-6>{+} c2
z = z * z + c
2. * c1
\ddd\end{codeblock}

\uncover<7>{}

\end{frame}

\begin{frame}[fragile]{Operator overloading}


  \begin{itemize}[<+->]
  \item \Cpp{} offers the possibility to define the meaning of most of the
    operators available for fundamental types when applied to user-defined types
  \item Syntactically this is done via the definition of appropriate functions
  \item Given an operator \textit{@}, the function name is called
    \code{operator\textit{@}}
  \item Although there are some constraints on the number and types of the
    parameters and on the type of the return value, the overloaded operators
    are just functions
  \item The behaviour of the overloaded operator should reproduce the behaviour
    of the original one
  \item Some behaviours cannot be changed, e.g. associativity
  \end{itemize}

\end{frame}

\begin{frame}{Exercises}
  \begin{itemize}
  \item Define some other operators and functions for Complex
  \item Write a function to compute the solutions of an equation of the form
    $ax^2 + bx + c = 0$, given the three coefficients
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{More data abstraction}

  Imagine to change the Complex type to use the polar form

  \begin{codeblock}
struct Complex \{
  double rho;
  double theta;
\};\end{codeblock}

  \begin{itemize}
  \item<2-> As a consequence, all client code has to change
    \begin{codeblock}
double norm2(Complex const& c) \{ return c.rho * c.rho; \}\end{codeblock}
  \item<3-> Not all combinations of $(\rho,\theta)$ are valid
    \begin{itemize}
    \item $\rho \geq 0, \theta \in [0, 2\pi)$
      \begin{codeblock}
Complex c\{-1, -1\}; // valid?
c.rho = -1;        // valid?\end{codeblock}
    \end{itemize}
  \end{itemize}

  \begin{itemize}
  \item<4-> We wish we could
    \begin{itemize}
    \item have more isolation between client code and implementation
    \item enforce an internal relation (\textit{class invariant}) between data
      members
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface}

  \begin{itemize}
  \item The internal representation of a data structure should be considered an
    implementation detail
  \item The manipulation of objects should happen through a
    well-defined function-based interface
  \item Known as \alert{encapsulation}
  \item<2-> Member variables are often named in a special way
    \begin{itemize}
    \item \code{_} suffix or \code{m_} prefix
    \end{itemize}
  \end{itemize}

\begin{codeblock}<2->{
\alert<2>{class} Complex \{
 \alert<2-4>{private}: // cartesian form
  double r_;
  double i_;
 \alert<2>{public}:
  // associated functions (member functions, also known as methods)
\};

\uncover<3->{Complex c\{1., 2.\}; // \alert<3>{error}}
\uncover<4->{auto norm2(Complex const& c) \{
  return c\alert<4>{.r_} * c\alert<4>{.r_} + c\alert<4>{.i_} * c\alert<4>{.i_}; // \alert<4>{error}
\}}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Construction}

  \begin{itemize}
  \item A special function, called \alert{constructor}, can be associated to a
    class to initialize the storage of an object of that type when it is created
    \begin{itemize}
    \item It should initialize the data members in order to establish the
      \textit{class invariant}
    \end{itemize}
  \item The constructor's name is the same as the class name
  \item<3-> Data members should preferably be initialized in the \textit{member
      initialization list}
  \end{itemize}

  \begin{codeblock}<2->{
class \alert<2>{Complex} \{
 private:
  double r_;
  double i_;
 public:
  \alert<2>{Complex}(double x, double y)\only<2>{ // no return type}
  \uncover<3->{    : r_\{x\}, i_\{y\} // \alert<3>{member initialization list}}
  \{ \uncover<4->{/* nothing else to do */} \}
  ...
\};

Complex c\{1., 2.\}; // or (1., 2.)}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface \insertcontinuationtext}

  \begin{itemize}
  \item The internal representation of a class should be considered an
    implementation detail
  \item The manipulation of objects should happen through a
    well-defined function-based interface

\begin{codeblock}
class Complex \{
 \alert<1>{private}:
  double r_;
  double i_;
 \alert<2>{public}:
  Complex(double x, double y) : r_\{x\}, i_\{y\} \{\}
  \visible<2->{double \alert<2>{real}() \{ return r_; \}\only<2>{ // member function (method)}
  double \alert<2>{imag}() \{ return i_; \}}
\};

double norm2(Complex c) \{
  return \only<1|trans:0>{c\alert{.r_} * c\alert{.r_} + c\alert{.i_} * c\alert{.i_}; // \alert{error}}\only<2->{c\alert<2>{.real()} * c\alert<2>{.real()} + c\alert<2>{.imag()} * c\alert<2>{.imag()};}
\}\end{codeblock}

  \item<3->For a \code{class}, \code{private} is the default and can be omitted
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}
  \item Member functions (methods) can of course also mutate an object
    \begin{codeblock}
class Complex \{
 public:
  void add(Complex const& other) \{
    r_ += other.r_; \uncover<3->{// no need to use other.real() (*)}
    i_ += other.i_;
  \}
  \ddd
\};

Complex c\{1., 2.\};
Complex d\{3., 4.\};
c.add(d);
c.real(); // 4.

\visible<2->{c.add(Complex\{3., 4.\}); // valid
c.add(\{3., 4.\});        // also valid}\end{codeblock}

  \item<3-> (*) Control of access to the private part is per class, not per object
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}
  \item Member functions that don't modify the object should be declared
    \textbf{\code{const}}

\begin{codeblock}
class Complex \{
  double r_;
  double i_;
 public:
  Complex(double x, double y) : r_\{x\}, i_\{y\} \{\}
  auto real() \alert{const}              // cannot modify this object
  \{ return r_; \}
  auto add(Complex const& other) // can modify this object
  \{ r_ += \ddd; \}
\};

Complex c\{1.,2.\};
c.real();                // ok
c.add(\{3.,4.\});          // ok
Complex const cc\{1.,2.\};
cc.real();               // ok
cc.add(\{3.,4.\});         // error\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}

  \item It's not rare to have functions with the same name, but in two different
    forms: one that reads and one that modifies the internal state
    \begin{itemize}
    \item Example of function overloading
    \end{itemize}

    \begin{codeblock}
class Complex \{
 public:
  double real()         const \{ return r_; \}
  void   real(double d)       \{ r_ = d; \}
  \ddd
\};\end{codeblock}

    \begin{columns}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
Complex c\{1.,2.\};
c.real(0.);
c.real();           // return 0.\end{codeblock}
      \end{column}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
Complex const c\{1.,2.\};
c.real(0.);         // error
c.real();           // ok\end{codeblock}
      \end{column}
    \end{columns}
    
  \item Alternatively, methods can be prefixed with \code{get_}/\code{set_}
    \begin{itemize}
    \item e.g. \code{double get_real();}, \code{void set_real(double);}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Member vs free function}
  \begin{codeblock}
class Complex \{
 public:
  double norm2() const \{ // \alert<1>{member function}
    return r_ * r_ + i_ * i_;
  \}
  \ddd
\};

double norm2(Complex const& c) \{ // \alert<1>{free function}
  return c.real() * c.real() + c.imag() * c.imag();
\}

Complex c\{\ddd\};
c.norm2(); // call the member function
norm2(c);  // call the free function\end{codeblock}

  \pause
  \begin{itemize}
  \item The public part of a class should ideally provide a safe, efficient and
    complete interface, yet minimal
  \item Prefer a free function, if possible
    \begin{itemize}
    \item Extend the functionality of a class without modifying existing code
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{std::string} \insertcontinuationtext}

  \begin{itemize}

  \item A user-defined type to represent a sequence of characters
  \item Provided by the C++ Standard Library
  \item Provides many member functions
    \begin{itemize}
    \item Construction
    \item Capacity (e.g. \code{size()}, \code{empty()})
    \item Assignment (e.g. \code{=}, \code{assign()})
    \item Comparison (\code{==}, \code{!=}, \code{<}, \code{>}, \code{<=}, \code{>=})
    \item Access to a character (e.g. \code{[]}, \code{back()}, \code{front()})
    \item Insertion/removal (e.g. \code{insert()}, \code{append()}, \code{erase()})
    \item Search (e.g. \code{find()})
    \item \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Construction \insertcontinuationtext}

  \begin{itemize}
    
  \item A class can have multiple constructors
    \begin{codeblock}
class Complex \{
  double r_;
  double i_;
 public:
  Complex(double x, double y) : r_\{x\}, i_\{y\} \{\}
  Complex(double x) : r_\{x\}, i_\{0.\} \{\}
  Complex() : r_\{0.\}, i_\{0.\} \{\} // \alert{default constructor}
  \ddd
\};

Complex c1\{1., 2.\};
Complex c2\{1.\};       // meaning \{1., 0.\}
Complex c3;           // or \{\}, meaning \{0., 0.\}; () cannot be used here
Complex cf();         // this is a function declaration!\end{codeblock}

  \item The default constructor (i.e. the constructor without parameters) can be
    automatically generated by the compiler, but only if there are no other
    constructors
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Construction \insertcontinuationtext}

  \begin{itemize}
  \item A constructor can \textbf{delegate} the construction to another, usually
    more generic, constructor

  \begin{codeblock}
class Complex \{
  double r_;
  double i_;
 public:
  Complex(double x, double y) : r_\{x\}, i_\{y\} \{\}
  Complex(double x) : Complex\{x, 0.\} \{\}      // \alert{delegating constructor}
  Complex() : Complex\{0., 0.\} \{\}             // \alert{delegating constructor}
  \ddd
\};

Complex c1\{1., 2.\};
Complex c2\{1.\};       // meaning \{1., 0.\}
Complex c3;           // meaning \{0., 0.\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Construction \insertcontinuationtext}

  \begin{itemize}
  \item A data member can be given a \textbf{default initializer}, which is used
    if the member is not explicitly initialized in the called constructor

  \begin{codeblock}
class Complex \{
  double r_\alert{\{0.\}};
  double i_\alert{\{0.\}};
 public:
  Complex(double x, double y) : r_\{x\}, i_\{y\} \{\}
  Complex(double x) : r_\{x\} \{\} // i_ initialized with 0
  Complex() \alert{= default}; // r_ and i_ initialized with 0
  \ddd
\};

Complex c1\{1., 2.\};
Complex c2\{1.\};       // meaning \{1., 0.\}
Complex c3;           // meaning \{0., 0.\}\end{codeblock}

  \item \code{= default} tells the compiler to generate the default implementation
    for a \textit{special member function} (such as the default constructor)
    \begin{itemize}
    \item Do not use \code{\{\}}
    \end{itemize}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Construction \insertcontinuationtext}

  \begin{itemize}
  \item For any function, a parameter can be given a default value, in case the
    corresponding argument is omitted
  \item Arguments can be omitted starting from the right
  \item \textbf{Default function arguments} can be used also for a constructor

  \begin{codeblock}
class Complex \{
  double r_;
  double i_;
 public:
  Complex(double x \alert{= 0.}, double y \alert{= 0.}) : r_\{x\}, i_\{y\} \{\}
  \ddd
\};

Complex c1\{1., 2.\};
Complex c2\{1.\};       // meaning \{1., 0.\}
Complex c3;           // meaning \{0., 0.\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{explicit} constructor}

  \begin{codeblock}
class Complex \{
  \ddd
  Complex(double x = 0., double y \alert<2-3>{= 0.}) : r_\{x\}, i_\{y\} \{\}
\};

double norm2(Complex const& c) \{ \ddd \}

norm2(1.);\uncover<2->{ // callable with a double (-> Complex)}
\uncover<3->{norm2(1);  // callable with an int (-> double -> Complex)}
\uncover<4->{c + 3;     // call operator+ with two Complex}
\uncover<5->{3 + c;     // call operator+ with two Complex, only if free function}\end{codeblock}

  \begin{itemize}
  \item<2-> The (one-parameter) constructor is used for the conversion
  \item<6-> An \code{explicit} constructor prevents the implicit conversion
  \end{itemize}

  \begin{codeblock}<6->{
class Complex \{
  \ddd
  \alert{explicit} Complex(double x = 0., double y = 0.) \ddd
\};

norm2(1.);          // error
norm2(Complex\{1.\}); // ok}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{explicit} constructor \insertcontinuationtext}

  \begin{itemize}
  \item An \code{explicit} constructor prevents also the implicit construction
    of an object from a list of arguments between braces
    \begin{itemize}
    \item e.g. in a function call or in a \code{return} statement
    \end{itemize}
  \end{itemize}

  \begin{columns}[t]
    \begin{column}{.45\textwidth}
      \begin{codeblock}
class Complex \{
  \ddd
  Complex(double x, double y) \ddd
\};

Complex operator+(\ddd)
\{
  \ddd
  return \{r, i\}; // ok
\}\end{codeblock}

    \end{column}

    \begin{column}{.55\textwidth}
      \begin{codeblock}
class Complex \{
  \ddd
  \alert{explicit} Complex(double x, double y) \ddd
\};

Complex operator+(\ddd)
\{
  \ddd
  // return \{r, i\}; // error
  return Complex\{r, i\}; // ok
\}\end{codeblock}

    \end{column}

  \end{columns}

  \begin{itemize}
  \item<2> Better start with explicit constructors, especially for the
    constructor callable with one argument, and relax the constraint later
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Pointers and data structures}

  \begin{itemize}
  \item<1-> \textit{address-of} operator: \alert{\code{\&}}
    \begin{itemize}
    \item Given an object it returns its address in memory
    \end{itemize}
  \item<2-> \textit{dereference} operator: \alert{\code{*}}
    \begin{itemize}
    \item Given a pointer to an object it returns a reference to that object
    \end{itemize}
  \item<3-> \textit{structure dereference} operator: \alert{\code{->}}
    \begin{itemize}
    \item Given a pointer to an object of class/struct type, it returns a
      reference to a member of that object
    \end{itemize}
    \begin{codeblock}
struct S \{
  int n;
  void f();
\};

S q\{\ddd\};
S* p = &q;
p->n;        // equivalent to (*p).n
p->f();      // equivalent to (*p).f()\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{The \code{this} pointer}

  Within the body of a member function of a class \code{T}, the keyword
  \textbf{\code{this}}
  \begin{itemize}
  \item is a pointer of type \code{T*} (or \code{T const*} if the method is
    \code{const})
  \item points to the object for which the method was called
  \end{itemize}

\begin{codeblock}<2->{
struct Foo \{
  void bar() \{
    ... \alert{this} ...;
  \}
\};

\uncover<3->{Foo alfa;}
\uncover<3->{Foo beta;}
\uncover<4->{alfa.bar(); // inside bar, this is &alfa}
\uncover<5->{beta.bar(); // inside bar, this is &beta}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{operator@} in terms of \code{operator@=}}

  \begin{itemize}
  \item Typically, a symmetric \code{operator@} (e.g. \code{operator+}) is
    implemented in terms of a member \code{operator@=} (e.g. \code{operator+=})
    \begin{codeblock}
Complex operator+(Complex const& lhs, Complex const& rhs)
\{
  Complex result\{lhs\};   // create the result as a copy of lhs
  return result += rhs;  // add rhs to the result and return it
\}\end{codeblock}

  \item<2-> Typically, \code{operator@=} returns a reference to the object being
    operated on

    \begin{codeblock}
class Complex \{
  \ddd
  Complex\alert{&} operator+=(Complex const& rhs) \{
    r_ += rhs.r_;
    i_ += rhs.i_;
    return \alert{*this}; // *this means self
  \}
\};\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}{Example: rational numbers}

  \begin{itemize}
  \item Let's implement a class to represent rational numbers
  \item The representation is with two integers, such that
    \begin{itemize}
    \item The fraction is irreducible, i.e. their GCD (Greatest Common
      Denominator) is $1$
    \item If the number is negative the sign is kept in the numerator
    \item The denominator is different from $0$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example: rational numbers \insertcontinuationtext}

  \begin{codeblock}
class Rational
\{
  int n_;
  int d_;
 public:
  Rational(int num = 0, int den = 1) : n_\{num\}, d_\{den\}
  \{
    if (d_ == 0) \{
      // construction must fail
    \}
    // reduce  
    auto const g\{ std::gcd(n_, d_) \}; // in <numeric>
    n_ /= g;
    d_ /= g;
    // fix sign
    if (d_ < 0) \{
      n_ = -n_;
      d_ = -d_;
    \}
  \}
  \ddd
\};\end{codeblock}

\end{frame}

\begin{frame}{Class invariant}

  \begin{itemize}[<+->]
  \item A \textbf{class invariant} is a relation between the data members of a
    class that constrains the values that such members can assume
    \begin{itemize}
    \item It defines what is a valid state for an object of that class
    \item It must always hold for an object of that class
    \end{itemize}
  \item The invariant is established by the constructor
  \item The invariant is preserved by \textbf{public} methods
    \begin{itemize}
    \item The invariant holds when the function is entered $\implies$ the
      implementation can make assumptions
    \item The invariant may be violated during the execution of the function
    \item The invariant is re-established before exiting the function
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{assert}}

  Check that a certain boolean expression is satisfied at run time
  \begin{itemize}
  \item for example, a class invariant at the end of a constructor or a
    condition at the beginning of a function (a \textit{pre-condition})
  \end{itemize}

  \begin{codeblock}<2->{
#include <cassert>

class Rational \{
  \ddd
  Rational(int num = 0, int den = 1) : n\{num\}, d\{den\} \{
    \ddd
    assert(std::gcd(n, d) == 1 && d > 0);
  \}
  Rational& operator/=(int n) \{
    assert(n != 0);
    \ddd
  \}
\};

bool operator==(Rational const& l, Rational const& r)
\{
  assert(std::gcd(l.num(), l.den()) == 1 && std::gcd(r.num(), r.den()) == 1);
  return l.num() == r.num() && l.den() == r.den();
\}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{assert} \insertcontinuationtext}

  \begin{itemize}
  \item If the asserted condition is not satisfied, it means that the state of the
    program does not conform to the expectations of the programmer, i.e. to the
    design
  \item The state may even be corrupted $\rightarrow$ it's probably wiser to
    \code{terminate} the program as soon as possible to avoid causing damage
  \item Very useful to identify logical errors (i.e. bugs)
    \begin{itemize}
    \item Be generous with the number of \code{assert}s in your code
    \end{itemize}
  \item Can be disabled for performance reasons (\code{g++ -DNDEBUG \ddd})
    \begin{itemize}
    \item Avoid side effects in \code{assert}s (e.g. assignments or calls to
      non-const methods), because they would disappear from the executable
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{assert} \insertcontinuationtext}

  \begin{itemize}
  \item \code{assert} (but also Doctest's \code{CHECK}) is a
    \textit{preprocessor macro}
  \item Macros obey syntactic rules that are different from those of C++ proper

    \begin{codeblock}<2->{
assert(Rational\{1\alert{,}2\} == Rational\{2\alert{,}4\});   // error (*)
assert(Rational\alert{(}1,2\alert{)} == Rational\alert{(}2,4\alert{)});   // ok
assert(\alert{(}Rational\{1,2\} == Rational\{2,4\}\alert{)}); // ok}\end{codeblock}

    {\tiny\begin{itemize}
    \item[*]<2-> macro "assert" passed 3 arguments, but takes just 1
    \end{itemize}}
  \item<3-> Macros \textit{expand} to arbitrary text, which is then passed to the
    real C++ compiler
  \item<3-> A bit more about the preprocessor later in the course
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions}

  \begin{itemize}
  \item Exceptions provide a general mechanism to:
    \begin{itemize}
    \item notify the occurrence of an error in the program execution, typically
      when a function is not able to accomplish its task, i.e. to satisfy its
      \textit{post-condition}
      \begin{itemize}
      \item using a \code{throw} expression
      \end{itemize}
    \item transfer control to a handler defined in a previous function in the call
      chain, where the exception can be managed
      \begin{itemize}
      \item using a \code{try}/\code{catch} statement
      \end{itemize}
    \end{itemize}
  \item<2-> Exceptions help separate application logic from error management
  \item<3-> A typical use is in constructors and operators, that have a fixed
    function signature
  \item<4-> Exceptions cannot be ignored
    \begin{itemize}
    \item If a handler is not found the program is \code{terminate}d
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions \insertcontinuationtext}
  \begin{columns}

    \begin{column}{.5\textwidth}
      \begin{codeblock}
struct E \{\};

auto function3() \{
  \ddd // this part is executed
  \alert{throw} E\{\};
  \ddd // this part is not executed
\}

auto function2() \{
  \ddd // this part is executed
  function3();
  \ddd // this part is not executed
\}

auto function1() \{
  \alert{try} \{
    \ddd // this part is executed
    function2();
    \ddd // this part is not executed
  \} \alert{catch} (E const& e) \{
    \ddd // use e
  \}
\}\end{codeblock}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{itemize}[<+->]
      \item An exception is an object
      \item After being raised (\code{throw}n), an exception is propagated up the stack
        of function calls until a suitable \code{catch} clause (handler) is
        found
      \item If no suitable handler (i.e. one compatible with the type of the
        exception) is found, the program is \code{terminate}d
      \item Exceptions should be caught by (const) reference
      \item During \textit{stack unwinding} the stack frames are properly
        cleaned up
      \end{itemize}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{Exceptions in constructors}

  \begin{itemize}
  \item An exception is typically raised by a constructor to inform that it is
    not able to properly initialize the object
    \begin{itemize}
    \item i.e. it's not able to establish the class invariant
    \end{itemize}
  \item Let's apply this to Rational, using the standard-provided exception \code{std::runtime_error}
    \begin{itemize}
    \item it can be constructed with a string or a string literal
    \item it provides a \code{what()} method to retrieve that string, e.g. in
      the handler
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions in constructors \insertcontinuationtext}

    \begin{codeblock}
class Rational \{
  \ddd
  Rational(int num = 0, int den = 1) : n\{num\}, d\{den\} \{
    if (d == 0) \{
      \alert{throw} std::runtime_error\{"denominator is zero"\}; // in <stdexcept>
    \}
    \ddd
  \}
\};

auto do_computation() \{
  \ddd
  Rational\{n,m\} // m here happens to be 0
  \ddd  
\}

\alert{try} \{
  do_computation();
  \ddd
\} \alert{catch} (std::runtime_error const& e) \{
  std::cerr << e.what() << \bslashn;
\}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Nested class}
  \begin{itemize}

  \item A class can be defined within the definition of another class
    \begin{itemize}
    \item in either the public or private section
    \end{itemize}

    \begin{codeblock}
class Regression \{
  \ddd
  \alert{class Result \{ \ddd \};}
  Result fit() const \{ \ddd \}
\};

Regression reg;
\ddd
Regression::Result result\{ reg.fit() \}; // or auto result\{\ddd\}\end{codeblock}

  \item<2-> The nested class can access the private members of the outer class
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Type alias}

  \begin{itemize}
  \item A type alias is another name for an existing type

  \begin{codeblock}
using Length = double;
typedef double Length; // equivalent, old alternative

Length len\{1.\}; // len is of type double\end{codeblock}

  \item<2-> A type alias does \textbf{not} introduce a new type

    \begin{codeblock}<2->{
void walk(double d) \{ \ddd \}
void walk(Length l) \{ \ddd \} // error, redefinition of walk}\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Type alias \insertcontinuationtext}

  \begin{itemize}
  \item Type aliases are often used to declare types within a class

    \begin{codeblock}
class FitResult \{ \ddd \};

class Regression \{
  \ddd
 public:
  \alert{using Result = FitResult;}
  Result fit() const \{ \ddd \}
\};

Regression::Result result\{ reg.fit() \}; // result is of type FitResult\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Structured binding}
  \begin{itemize}
  \item A \textit{structured binding} declaration declares multiple variables
    and initializes them from values of struct members (and other entities,
    following a certain \textit{protocol})
    \begin{codeblock}
struct Point \{
  double x;
  double y;
\};

Point p\{1.,2.\};
auto [a, b] = p;
std::cout << a << \upquote{ } << b; // print 1 2\end{codeblock}

  \item<2-> The variables can be declared as (const) references to the struct members
    \begin{codeblock}
Point p\{1.,2.\};
auto& [a, b] = p; // a is a ref to p.x, b is a ref to p.y
a = 3.;
b = 4.;
std::cout << p.x << \upquote{ } << p.y; // print 3 4\end{codeblock}

  \end{itemize}
\end{frame}

